The [slides for this talk](/assets/ConstructiveAnalysis.slides.html) are also available.

## Introduction to Constructive Mathematics

> It was proven by Cantor that a good math joke exists. Unfortunately, his proof was
> entirely non-constructive.

Attribution: [Jon](https://mathoverflow.net/a/2960)

> My homework does exist, but no one can find it.

Attribution: Printed in The Times of London, February 3, 2004. Obtained from Bridges and
VÃ®Å£Äƒ.

Constructive mathematics is mathematics that avoids obscuring the underlying algorithms and
their computational information. A *constructive* proof is, or is readily turned into, an
algorithm to find the thing itâ€™s claiming.

It is easier to understand constructivism by looking at what procedures in proofs are not
constructive. Here is a theorem in elementary calculus:

**Theorem**. There exist ``\{a, b\} âŠ† ğ‘^+ - ğ^+`` such that ``a^b âˆˆ ğ^+``. (There are two
irrational numbers ``a``, ``b`` with ``a^b`` rational.)

Here is a non-constructive proof:

**Proof**. Consider ``\sqrt{2}^\sqrt{2}``. If it is rational, we are done. Otherwise,
``{\left(\sqrt{2}^\sqrt{2}\right)}^{\sqrt{2}} = \sqrt{2}^2 = 2`` is rational, and we are
done.

This proof is classically valid. But imagine we needed these numbers ``a``, ``b`` for the
correctness of some algorithm. Which numbers would we use: ``a = b = \sqrt{2}`` or ``a =
\sqrt{2}`` and ``b = \sqrt{2}^{\sqrt{2}}``? Here shows the difficulty of a non-constructive
proof: while it makes the claim that the requested numbers ``a`` and ``b`` exist, it does
not give any way to construct those numbers. Thus it is unsuitable for algorithmic purposes.

Here is a constructive proof.

**Proof**. Let ``a = \sqrt{2}`` and ``b = \frac{\log{9}}{\log{2}}``. Then
``a^b = 3`` which is rational, and we are done.

This proof is constructive because we can immediately use it in any algorithm requesting
such numbers ``a`` and ``b``, as they are constructed in the proof.

Let us try to turn the first proof into an algorithm, so we can better see what goes wrong.

```julia
# Compute `a, b` where `a` and `b` are irrationals such that `a^b` is rational.

if (âˆš2) ^ (âˆš2) âˆˆ ğ
    a = âˆš2
    b = âˆš2
else
    a = (âˆš2) ^ (âˆš2)
    b = âˆš2
end
```

If we try to implement this algorithm, we see immediately what is wrong: implementing the
condition `(âˆš2) ^ (âˆš2) âˆˆ ğ` is hard. To have such an algorithm that can determine whether
`(âˆš2) ^ (âˆš2)` is rational, we would need to prove that it is rational, or that it is
irrational.

Note that in a non-constructive logic, the proof was valid because we could simply assume
that a correct decision can be made â€” though the proof does not tell us how to make it.
This is called the  Law of the Excluded Middle, an inference rule of non-constructive
mathematics:

```math
âŠ¢ P âˆ¨ Â¬P
```

The Law of the Excluded Middle, from an algorithmic standpoint, is equivalent to total
omniscience. If for any proposition ``P`` we had an algorithm that determines the truth of
``P``, then using this law is valid constructively â€” as we would simply ask that algorithm
which branch to take.

Unfortunately, modern computers do not support omniscience, so the Law of the Excluded
Middle cannot be used in constructive proofs.

## Logic

There is not a single theory of constructivism; different mathematicians have developed
different approaches. Many modern mathematicians subscribe to a theory of constructivism
built on intuitionistic logic: in particular, the BHK interpretation.

The ideas behind the BHK interpretation are very simple:

- A proof of ``a âˆ§ b`` is a proof of ``a`` and a proof of ``b``
- A proof of ``a âˆ¨ b`` is a proof of ``a`` or a proof of ``b``
- A proof of ``âˆ€ x P(x)`` is an algorithm that given any ``x``, creates a proof of ``P(x)``
- A proof of ``âˆƒ x P(x)`` is a **witness** ``x`` and a proof of ``P(x)``
- A proof of ``a â‡’ b`` is an algorithm that given a proof of ``a`` creates a proof of ``b``
- A proof of ``Â¬a`` is a **refutation** of ``a``

Here, a witness is a value that can be computed by an algorithm that demonstrates
constructively the existential proposition.

Note the two major differences from classical logic: in BHK, a proof of a disjunction is a
proof of one of the disjuncts. This makes more clear why the Law of the Excluded Middle must
be excluded from the BHK interpretation, as taking ``âŠ¢ P âˆ¨ Â¬P`` as an axiom results in
something that purports to be a proof of ``P âˆ¨ Â¬P``, but is neither a proof of ``P``, nor is
it a proof of ``Â¬P``. Furthermore, a proof of an existential must explicitly give a witness.
Many classical proofs of existentials do not accomplish that.

We should clarify the meaning of the word **refutation** used above. A refutation of ``a``
is an algorithm that given a proof of ``a`` constructs a contradiction. There is special
syntax commonly used to denote contradictions: ``âŠ¥``. Therefore, we can alternatively
interpret ``Â¬a`` as ``a â‡’ âŠ¥``.

## Limited Omniscience

Although we used the law of the excluded middle in our non-constructive proof above, that
does not mean that the statement cannot be proved in constructive mathematics. It merely
means that the particular proof we used involved total omniscience. (In fact, we did give a
constructive proof of this shortly after.)

Can every statement of classical mathematics be proven constructively, even if the currently
known proofs involve invoking some form of omniscience? Well, some statements are themselves
forms of omnisicence. (For example, it is hard to envision the law of the excluded middle
being provable constructively, as that would imply an algorithm to decide the truth of any
logical formula.)

We can measure the degree to which a statement ``P`` of classical mathematics is **not**
provable constructively by showing that ``P â‡’ Q`` constructively, where ``Q`` is some
principle that seems to require a certain degree of omniscience. In the most general case,
we might show that a statement ``P`` implies the full law of the excluded middle. However,
it is possible that ``P`` implies some other form of omniscience that is weaker than being
able to decide the truth of *anything*.

### Limited Principle of Omniscience

```math
âˆ€ğ±âˆˆ\{0, 1\}^ğ (ğ± = ğŸ âˆ¨ ğ± â‰  ğŸ)
```

Here we must be careful to define the equality and inequality of binary sequences. We define
equality to be

```math
ğ± = ğ² â‡” âˆ€iâˆˆğ (x_i = y_i)
```

and inequality to be

```math
ğ± = ğ² â‡” âˆƒiâˆˆğ (x_i â‰  y_i)
```

Note that the natural inequality is **not** the same as a refutation of equality; in fact it
is stronger. (We will see this come up again with real numbers.) This kind of inequality is
called a â€œtight apartnessâ€. A simple refutation of equality, ``Â¬(a = b)``, would be called
the â€œdenial inequalityâ€.

An informal way to understand this principle is that, given an infinitely tall haystack,
either it has no needles or it has a needle. No algorithm can decide this in general, as it
would involve scanning through infinitely many 0s. Thus this is a form of omniscience
(knowing an infinite number of things), though less powerful than the total omniscience of
the Law of the Excluded Middle.

### Lesser Limited Principle of Omniscience

```math
âˆ€ğ±âˆˆ\{0, 1\}^ğ (Â¬âˆƒiâˆˆğ,jâˆˆğ(iâ‰ j âˆ§ x_i = y_i = 1) â‡’ (âˆ€iâˆˆğ(x_{2i} = 0) âˆ¨ âˆ€iâˆˆğ(x_{2i-1} = 0)))
```

This statement is rather complicated, but can be understood less formally as: given two
infinitely tall haystacks, if you know that there is at most one needle among them both,
then either the left haystack has no needles or the right haystack has no needles. To decide
this would seemingly also require scanning a potentially unbounded amount of time to find
the right haystack (since it is possible that neither haystack contains a needle), and hence
is also a form of omniscience. However, it is weaker than the LPO.

### Markov Principle

Even weaker still is the so-called Markov principle,

```math
âˆ€ğ±âˆˆ\{0, 1\}^ğ (Â¬(ğ± = ğŸ) â‡’ ğ± â‰  ğŸ)
```

The Markov principle is the statement that in fact the double negative does hold for
equality of binary sequences; furthermore it shows that the denial inequality and tight
apartness are the same in these cases. It would seem like there does exist an algorithm to
find a witness to the inequality of two sequences: simply search through the sequence and
wait to find the first 1. This should terminate because since the sequence is not all zeros,
there must be a 1! However, note that this reasoning involves the use of a classical logic
non-constructive argument: that is, the termination of the algorithm isnâ€™t explicitly shown
by providing a witness bounding the amount of time it will take, but shown through a
classical-style contradiction argument. Hence the Markov principle only holds in the BHK
interpretation if the logic you use to reason about it is a classical metatheory, and is
otherwise not part of the BHK interpretation.

## Brouwerian Counterexamples

A Brouwerian counterexample for a statement ``P`` is a proof that ``P â‡’ \mathsf{LEM}`` or
``P â‡’ \mathsf{LPO}`` or ``P â‡’ \mathsf{LLPO}`` or even ``P â‡’ \mathsf{MP}``. Brouwerian
counterexamples show that particular statements are not provable constructively, because
they imply omniscience principles that are inherently non-constructive.

These are useful to identify what statements from classical logic must be modified to fit
within a constructive framework. Indeed, if a statement does not have a Brouwerian
counterexample, it may be provable constructively even if the standard classical proof is
not constructive â€” perhaps the constructive one is just a little harder to find. But if a
statement does have a Brouwerian counterexample, then it cannot be proven in a constructive
framework unless somehow the omniscience principles can be proven.

## Construction and Operations on the Real Numbers

Weâ€™ll construct a real number as a set of rational intervals such that any two intervals
overlap, and there are intervals shorter than any given positive rational. Intuitively, a
real number is given by a set of rational interval approximations. Thinking of it from an
interface standpoint, we want to be able to get arbitrarily small rational brackets for the
real number:

```julia
abstract type RealNumber end

"""
    approximate(x::RealNumber, É›)

Return a rational interval of length at most É› containing x.
"""
function approximate(x::RealNumber, É›::Rational)
    ...
end
```

Here is a definition in the more usual symbology:

Each ``ğ±âˆˆğ‘`` is a set of rational intervals ``(q, q') âˆˆ ğ^2``
such that:

  - ``q â‰¤ q'``
  - ``âˆ€ (q, q') âˆˆ ğ±(âˆ€ (p, p') âˆˆ ğ±(q â‰¤ p' âˆ§ p â‰¤ q'))``
  - ``âˆ€ É›âˆˆ ğ^+ (âˆƒ (q, q') âˆˆ ğ± (q' - q < É›))``

Initially we will use boldface ``ğ±`` to denote real numbers. This will help to disambiguate
the differences between reals and rationals.

We will need an equivalence relation on this set to recover the reals. We can define it
quite naturally: two reals ``ğ±`` and ``ğ²`` are equivalent if every possible approximation
for them agree; that is, every interval in the sets overlaps. More symbolically:

```math
ğ± = ğ² := âˆ€(p, p')âˆˆğ± âˆ€(q, q')âˆˆğ² (\max\{p, q\} â‰¤ \min\{p', q'\})
```

We must be careful with the denial inequality ``Â¬(ğ± = ğ²)``: as we have mentioned earlier, if
``Â¬Â¬(ğ± = ğ²) â‡’ (ğ± = ğ²)``, then in fact we have the Markov principle. This is an example of a
Brouwerian counterexample â€” our first!

The tight apartness relation, which we will denote as ``ğ± â‰  ğ²``, does satisfy ``Â¬(ğ± â‰  ğ²) â‡’
(ğ± = ğ²)``. The definition of this will be that two real numbers are apart if there are
intervals that do not overlap. Another way to express that would be ``|ğ± - ğ²| > 0``, but we
cannot define that until later.

We have hinted above at a notion of apartness based on whether intervals do not overlap; we
can similarly define an order with the same idea, except directionally:

- ``ğ± < ğ²`` if there are intervals ``(p, p') âˆˆ ğ±`` and ``(q, q') âˆˆ ğ²`` that satisfy ``p' < q``
- ``ğ± â‰¤ ğ²`` if all intervals ``(p, p') âˆˆ ğ±`` and ``(q, q') âˆˆ ğ²`` satisfy ``p â‰¤ q'``
- ``ğ± > ğ²`` if there are intervals ``(p, p') âˆˆ ğ±`` and ``(q, q') âˆˆ ğ²`` that satisfy ``p > q'``
- ``ğ± â‰¥ ğ²`` if all intervals ``(p, p') âˆˆ ğ±`` and ``(q, q') âˆˆ ğ²`` satisfy ``p' â‰¥ q``

It is immediate that ``ğ± â‰® ğ² â‡” ğ± â‰¥ ğ²`` (we need only the decidability of ``â‰¥`` over the
rationals to prove this fact). However, some classical properties of these orders do not
hold. For example ``ğ± â‰¤ ğŸ âˆ¨ ğ± â‰¥ ğŸ`` implies ``\mathsf{LLPO}``, and ``ğ± â‰¥ ğŸ â‡’ (ğ± > ğŸ âˆ¨ ğ± =
ğŸ)`` implies ``\mathsf{LPO}``.  This also means, with the tight apartness above, that ``ğ± =
ğŸ âˆ¨ ğ± â‰  ğŸ`` implies ``\mathsf{LPO}``. These are also Brouwerian counterexamples.

We finish with some definitions for convergent and Cauchy sequences, which remind us of the
classical definitions, because they are the same:

- ``(ğ±_n) âˆˆ ğ‘^ğ`` **converges to** ``ğ±_âˆ`` if for all ``É› > 0`` there exists ``Nâˆˆğ`` after
  which any term ``ğ±_n`` (``n â‰¥ N``) is within ``É›`` of ``ğ±_âˆ``

- ``(ğ±_n) âˆˆ ğ‘^ğ`` is **Cauchy** if for all ``É› > 0`` there exists ``Nâˆˆğ`` after which any
  two terms ``ğ±_n``, ``ğ±_m`` (``n â‰¥ m > N``) are within ``É›`` of each other

## Completeness of the Real Numbers

We are going to provide sketch proofs of various facts that build up, constructively, the
completeness of ``ğ‘``, as well as the Archimedean property. For full proofs of the following
theorems, consult Bridges and VÃ®Å£Äƒ.  We will give a short overall sketch.

**(Theorem: Archimedean Property)** For each real number ``ğ±`` there exists a positive
integer ``n`` with ``|ğ±| < n``. (Bridges and VÃ®Å£Äƒ Lemma 2.1.15)

The proof of this is straightforward; we take any rational interval ``(q, q') âˆˆ ğ±`` and find
``n`` with ``\max\{|q|, |q'|\} < n``. The rest can be done with rational arithmetic. âˆ

**(Corollary)** For each real number ``ğ±`` there exists ``nâˆˆğ`` such that whenever ``(q, q')
âˆˆ ğ±`` and ``q' - q < 1``, we have ``\max\{|q|, |q'|\} < n``. (Bridges and VÃ®Å£Äƒ Lemma 2.1.20)

This is quite an easy corollary of the Archimedean Property (take the ``n`` from there and
add 1), but it is a stronger result that we will use later on. âˆ

**(Theorem)**
If ``(ğ±_n)_{nâˆˆğ} âˆˆ ğ‘^ğ`` is Cauchy, then there exists ``ğ±_âˆâˆˆğ‘`` such that ``\lim_{nâ†’âˆ} ğ±_n =
ğ±_âˆ``. (We call this the completeness of the real numbers. Intuitively, it means there are
no gaps.) (Bridges and VÃ®Å£Äƒ Theorem 2.1.21)

For the proof, let ``(ğ±_n)_{nâˆˆğ}`` be a Cauchy sequence.

Compute an integer function ``k \mapsto n_k`` such that each ``n_k`` satisfies for all
``m\ge n_k``, ``n\ge n_k``, ``|ğ±_m - ğ±_n| < 2^{-k}``.

For each ``k``, construct a sequence of intervals ``(q_k, q'_k) âˆˆ ğ±_{n_k}`` such that ``q'_k
- q_k < 2^{-k}``.

Consider ``r_k = q_k - 2^{-k}``, ``r'_k = q'_k + 2^{-k}``. For all ``nâ‰¥n_k``, we have

```math
r_k \le ğ±_{n_k} - 2^{-k} < ğ±_n < ğ±_{n_k} + 2^{-k} â‰¤ r_k
```

So actually for all ``j â‰¥ k``:

```math
ğ±_{n_j} âˆˆ [r_j, r'_j] âˆ© [r_k, r'_k]
```

So the real number ``ğ±_âˆ`` defined by ``\{(r_k, r'_k) : k \ge 1\}`` is in fact a real
number.

From our construction, we have ``ğ±_n \in [r_k, r'_k]`` for all ``n \ge n_k``. Then

```math
\forall k \forall nâ‰¥n_k (|ğ±_n - ğ±_âˆ| â‰¤ r'_k - r_k < 2^{-k+2})
```

Thus indeed ``(ğ±_n)_{nâˆˆğ}`` converges to ``ğ±_âˆ`` as required. âˆ
